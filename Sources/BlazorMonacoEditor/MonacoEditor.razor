@using BlazorMonacoEditor.Interop
@using BlazorMonacoEditor.Scaffolding
@using Microsoft.CodeAnalysis.Text
@using System.Reactive.Subjects
@using System.Reactive.Disposables
@using System.Reactive
@using System.Reactive.Linq
@using System.Threading
@inject MonacoInterop MonacoInterop
@inject ILogger<MonacoEditor> Logger
@implements IAsyncDisposable

<div @ref="monacoContainer" class="monaco-editor-container"></div>

@code {
    private readonly MonacoRoslynAdapter roslynAdapter = new();
    private readonly Subject<string> updateEditorSink = new();

    private bool showLineNumbers;
    private bool showCodeMap;
    private ElementReference monacoContainer;
    private CodeEditorFacade? editor;
    private TextModelFacade? currentTextModel;
    private string languageId = string.Empty;

    public CompositeDisposable Anchors { get; } = new();
    
    [Parameter]
    public ITextModel? TextModel { get; set; }

    [Parameter]
    public string LanguageId
    {
        get => languageId;
        set
        {
            if (string.Equals(languageId, value))
            {
                return;
            }

            languageId = value;
            LanguageIdChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<string> LanguageIdChanged { get; set; }

    [Parameter] public string? Theme { get; set; }

    [Parameter] public int? LineNumbersMinChars { get; set; }

    [Parameter]
    public bool ShowLineNumbers
    {
        get => showLineNumbers;
        set
        {
            if (showLineNumbers == value)
            {
                return;
            }

            showLineNumbers = value;
            ShowLineNumbersChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<bool> ShowLineNumbersChanged { get; set; }

    [Parameter]
    public bool ShowCodeMap
    {
        get => showCodeMap;
        set
        {
            if (showCodeMap == value)
            {
                return;
            }

            showCodeMap = value;
            ShowCodeMapChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<bool> ShowCodeMapChanged { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogDebug("First Render");

            editor = await MonacoInterop.CreateEditor(monacoContainer);
            Logger.LogDebug("Editor Created");
            var editorSubscription = updateEditorSink
                .SelectAsync(async (reason, token) => UpdateEditor(reason, token))
                .Subscribe();
            Anchors.Add(editorSubscription);
            updateEditorSink.OnNext("OnAfterRenderAsync");
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        updateEditorSink.OnNext("OnParametersSetAsync");
    }

    private async Task UpdateEditor(string reason, CancellationToken cancellationToken)
    {
        if (editor == null)
        {
            return;
        }

        var textModel = TextModel ?? new TextModel();
        var modelUri = new Uri($"inmemory://{editor.Id}/{textModel.Path}");
        var differentUri = !string.Equals(modelUri.ToString(), currentTextModel?.Uri.ToString());
        
        if (currentTextModel == null || differentUri)
        {
            if (currentTextModel != null)
            {
                await currentTextModel.DisposeAsync();
            }
            
            Logger.LogDebug($"Requesting text from text model: {textModel}");
            var actualText = await textModel.GetTextAsync(cancellationToken);

            currentTextModel = await MonacoInterop.CreateTextModel(modelUri, string.Empty, LanguageId);
            Logger.LogDebug($"Created model: {currentTextModel}");
            await editor.SetModel(currentTextModel);
            await currentTextModel.SetContent(actualText.ToString());

            var modelSubscription = currentTextModel
                .WhenModelContentChanged
                .SubscribeAsync(async (x, token) =>
                {
                    try
                    {
                        var currentText = await textModel.GetTextAsync(token);
                        var updatedText = roslynAdapter.ApplyChanges(currentText, x);
                        await textModel.SetTextAsync(updatedText, token);
                    }
                    catch (Exception e)
                    {
                        Logger.LogError($"Failed to apply changes to text model {textModel}", e);
                        throw;
                    }
                });
            currentTextModel.Anchors.Add(modelSubscription);
        }
        
        await UpdateOptionsIfNeeded();
    }

    private async Task UpdateOptionsIfNeeded()
    {
        if (editor == null)
        {
            throw new InvalidOperationException("Editor is not loaded yet");
        }

        var options = new EditorOptions()
        {
            LineNumbers = ShowLineNumbers ? "on" : "off",
            LineNumbersMinChars = LineNumbersMinChars,
            Minimap = new EditorMinimapOptions()
            {
                Enabled = ShowCodeMap
            }
        };
        await editor.UpdateOptions(options);
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);
    }

    public async ValueTask DisposeAsync()
    {
        Anchors.Dispose();
        if (editor != null)
        {
            await editor.DisposeAsync();
        }

        if (currentTextModel != null)
        {
            await currentTextModel.DisposeAsync();
        }
    }
}