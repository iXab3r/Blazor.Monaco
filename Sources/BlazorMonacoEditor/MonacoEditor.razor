@using BlazorMonacoEditor.Interop
@using BlazorMonacoEditor.Scaffolding
@using Microsoft.CodeAnalysis.Text
@using System.Reactive.Subjects
@using System.Reactive.Disposables
@using System.Reactive
@using System.Reactive.Linq
@using System.Threading
@inject MonacoInterop MonacoInterop
@inject ILogger<MonacoEditor> Logger
@implements IAsyncDisposable

<div @ref="monacoContainer" class="monaco-editor-container"></div>

@code {
    private readonly MonacoRoslynAdapter roslynAdapter = new();
    private readonly Subject<string> updateEditorSink = new();

    private bool showLineNumbers;
    private bool showCodeMap;
    private ElementReference monacoContainer;
    private CodeEditorFacade? editor;
    private TextModelFacade? currentTextModel;
    private SourceText? sourceText;
    private string? path;
    private string languageId = string.Empty;

    public CompositeDisposable Anchors { get; } = new();

    [Parameter]
    public string? Path
    {
        get => path;
        set
        {
            if (string.Equals(path, value))
            {
                return;
            }

            path = value;
            PathChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<string?> PathChanged { get; set; }

    [Parameter]
    public SourceText? SourceText
    {
        get => sourceText;
        set
        {
            if (TextChanged.HasDelegate && SourceTextChanged.HasDelegate)
            {
                throw new InvalidOperationException($"Invalid configuration - only one of {nameof(TextChanged)} or {nameof(SourceTextChanged)} must be subscribed to");
            }

            if (ReferenceEquals(sourceText, value))
            {
                return;
            }
            
            if (value != null && sourceText != null && value.ContentEquals(sourceText))
            {
                return;
            }

            sourceText = value;
            SourceTextChanged.InvokeAsync(value);
            if (TextChanged.HasDelegate)
            {
                TextChanged.InvokeAsync(value?.ToString());
            }
        }
    }

    [Parameter] public EventCallback<SourceText> SourceTextChanged { get; set; }

    [Parameter]
    public string? Text
    {
        get => sourceText?.ToString();
        set
        {
            if (TextChanged.HasDelegate && SourceTextChanged.HasDelegate)
            {
                throw new InvalidOperationException($"Invalid configuration - only one of {nameof(TextChanged)} or {nameof(SourceTextChanged)} must be subscribed to");
            }

            var valueAsSourceText = value != null ? SourceText.From(value) : null;
            if (valueAsSourceText != null && sourceText != null && valueAsSourceText.ContentEquals(sourceText))
            {
                return;
            }

            SourceText = valueAsSourceText;
        }
    }

    [Parameter] public EventCallback<string> TextChanged { get; set; }

    [Parameter]
    public string LanguageId
    {
        get => languageId;
        set
        {
            if (string.Equals(languageId, value))
            {
                return;
            }

            languageId = value;
            LanguageIdChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<string> LanguageIdChanged { get; set; }

    [Parameter] public string? Theme { get; set; }

    [Parameter] public int? LineNumbersMinChars { get; set; }

    [Parameter]
    public bool ShowLineNumbers
    {
        get => showLineNumbers;
        set
        {
            if (showLineNumbers == value)
            {
                return;
            }

            showLineNumbers = value;
            ShowLineNumbersChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<bool> ShowLineNumbersChanged { get; set; }

    [Parameter]
    public bool ShowCodeMap
    {
        get => showCodeMap;
        set
        {
            if (showCodeMap == value)
            {
                return;
            }

            showCodeMap = value;
            ShowCodeMapChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<bool> ShowCodeMapChanged { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogDebug("First Render");

            editor = await MonacoInterop.CreateEditor(monacoContainer);
            Logger.LogDebug("Editor Created");
            var editorSubscription = updateEditorSink
                .Select(reason => Observable.FromAsync(token => UpdateEditor(reason, token)).Take(1)).Concat()
                .Subscribe();
            Anchors.Add(editorSubscription);
            updateEditorSink.OnNext("OnAfterRenderAsync");
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        updateEditorSink.OnNext("OnParametersSetAsync");
    }

    private async Task UpdateEditor(string reason, CancellationToken cancellationToken)
    {
        if (editor == null)
        {
            return;
        }
        
        var modelUri = new Uri($"inmemory://{editor.Id}/{Path}");
        if (currentTextModel == null || currentTextModel.Uri != modelUri)
        {
            if (currentTextModel != null)
            {
                await currentTextModel.DisposeAsync();
            }

            currentTextModel = await MonacoInterop.CreateTextModel(modelUri, string.Empty, LanguageId);
            Logger.LogDebug($"Created model: {currentTextModel}");
            await editor.SetModel(currentTextModel);
            await currentTextModel.SetContent(sourceText?.ToString() ?? string.Empty);

            var modelSubscription = currentTextModel
                .WhenModelContentChanged
                .Subscribe(x =>
                {
                    var currentText = SourceText ?? SourceText.From(string.Empty);
                    var updatedText = roslynAdapter.ApplyChanges(currentText, x);
                    SourceText = updatedText;
                });
            currentTextModel.Anchors.Add(modelSubscription);
        }
        
        await UpdateOptionsIfNeeded();
    }

    private async Task UpdateOptionsIfNeeded()
    {
        if (editor == null)
        {
            throw new InvalidOperationException("Editor is not loaded yet");
        }

        var options = new EditorOptions()
        {
            LineNumbers = ShowLineNumbers ? "on" : "off",
            LineNumbersMinChars = LineNumbersMinChars,
            Minimap = new EditorMinimapOptions()
            {
                Enabled = ShowCodeMap
            }
        };
        await editor.UpdateOptions(options);
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);
    }

    public async ValueTask DisposeAsync()
    {
        Anchors.Dispose();
        if (editor != null)
        {
            await editor.DisposeAsync();
        }

        if (currentTextModel != null)
        {
            await currentTextModel.DisposeAsync();
        }
    }
}